= roles of os =
- the os abstracts things for us
    - adds high level abstractions
    - dont need to worry about hardware
- its a resource manager
    - manages allocating resources to users and processes
    - makes sure system is efficiently used

= structure of an os =
- how do programs interface with the os?
    programs using the given system libraries which has a wrapper which invoke a syscall, which offers a way to interfece with the hardware in cooperation with the OS to transition between user mode and kernel mode with a request, like open a file. This request will be handled by the OS and it'll return the result to the application
- not all operating systems run on microprocessors that have a privileged component
    - this means that applications indirectly have access to all of memory; they indirectly can just access kernel mode functionalities with a function call.
    - since it has access to all of memory, we NEED the application to run fine or not be malicious since if that happens, the entire system will crash
    - these operating systems can provide the functionality of syscalls to protect the os, but they cant enforce it (programs can just say nah and run the function call and theres nothing they can do about it

= system libs =
- we can actually think of system libs as two different things;
    - one subset are pure library functions; they manipulate memory within the application or do computations but don't actaully interface with the kernel or run any syscalls (strcmp(), memcpy())
    - the other subset help cross the user-kernel boundary with syscalls, which is mainly focused on passing the request to the os and getting a result back to the system. (open(), close(), read(), write())
    - `man syscall` shows u linux syscalls :D 
    - printf? you give it a string and encoding wiht %d, etc - that manipuation to create a buffer to print that variable is within the library but the actual printing process is the syscall write (remmeber x86_64 with rax = 1?) 
      
= OS software vs user software =
- theres no real difference between os software and user space software
- theyre the same machine instructions generated by a compiler
- the difference between os software and user space software is determined by the mode the chip is in when running those instructions
- when we are in privileged mode, we have more instructions that applications dont have
    - you can put those instructions in your user space code, but if it tries to execute those instructions while in user space, the hardware doesn't like it and gives the os control

= running user space code? =
given that the os is running at any point in time, how does the application have a chance to run? 
- the operating system relinquishes control to the cpu to the application and when that happens, it drops from kernel mode to user mode.
- but then how does the OS get control again? if my application has a while(true) and runs forever and never returns to the OS?
    - the operating system has a timer that sends regular interrupts to the cpu, and when an interrupt occurs, the os gets control again and it decides what to do.
    - when the application does a syscall and transfers back control to the os they also get back control.

